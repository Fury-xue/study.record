
#+TITLE: Encrypt
#+AUTHOR:Simon
#+EMAIL: xue.shumeng@yahoo.com
#+KEYWORDS: encrypt
#+OPTIONS: H:1 toc:0

* RSA
** 公式和概念
   *公式：*
   | 公钥 KU | n：两个素数p和q的乘积（pq须保密） e：与(p-1)(q-1)互质 |
   |---------+-------------------------------------------------------|
   | 私钥 KR | d：e^-1(mod(p-1)(q-1)) n:                             |
   |---------+-------------------------------------------------------|
   | 加密    | c = m^e mod n (此处为同余运算)                                |
   |---------+-------------------------------------------------------|
   | 解密    | m = c^d mod n (同上，同余运算)                               |
   *概念：* 
   - 素数/质数，只能除尽自身和1的数
   - 互质数，公约数只有1的两个数
   - 模运算，如 5 mod 3 = 2，即：两数取余
   - 模质运算，即：先做质数运算，对其结果再做模运算。如5^3 mod 7 = 125 mod 7 = 6
   - 欧拉函数，对于一个正整数 n ，小于 n 且和 n 互质的正整数（包括 1）的个数，记作 φ(n)
   - 模反元素，如：ed ≡ 1 (mod φ(n))，整数d可使ed对f(n)取余为1
   - 费马小定理，假如p是质数，若p不能整除a，则a^(p-1) ≡ 1 (mod p),若p能整除a，则a^(p-1) ≡ 0 (mod p)。若p是质数，且a、p互质，那么a的(p-1)次方除以p的余数恒等于1
     - *证明* 因为p是质数，且(a,p) = 1，所以φ(p) = p-1。由欧拉定理可得a^(p-1) ≡ 1 (mod p)
     - 对于上式又有a^p ≡ a (mod p)，所以费马小定理的另一种表述为： *假如p是质数(素数)，且(a,p) = 1，那么a^p ≡ a (mod p)*
   - *欧拉定理* ，也称费马-欧拉定理。若n、a为正整数，且n、a互素，即：gcd(a,n) = 1，则：a^φ(n) ≡ 1 (mod n)
** 算法步骤
   1. 选择一组大素数p和q -> p=3,q=11
   2. 计算n=pq，此处n的二进制格式的bitu位数即是密钥长度。RSA密钥长度一般是1024位，更重要场合使用2048位 -> n = pq = 3*11 = 33
   3. 计算欧拉函数 f(n) = (p-1)(q-1) ,此时p和q的值应严格保密 -> f(33) = (3-1)(11-1) = 20
   4. 取f(n)的互质数e，满足：1 < e < f(n)，且e与f(n)互质 -> e = 3
   5. 计算e对于f(n)的模反元素d的值，ed ≡ 1 (mod f(n)) (“≡”为同余符号) 
      1. ed ≡ 1 (mod f(n))
      2. ed ≡ 1 (mod f(n)), 3d ≡ 1 (mod 20)
      3. 1 = ed + f(n)y, 3d + 20y = 1
      4. 先阶段位通过试数法得：d = 7, y = -1 实际应用中可通过“扩展欧几里得算法”对此二元一次方程求解
   6. 公钥 = (n,e) = (33,3),私钥 = (n,d) = (33,7)
   7. 加密：m^e ≡ c (mod n),m必须为数字，字符串可将其转为ASCII或UNICODE值，且m必须小与n
      1. 编码明文，我们将“LOVE”加密，ASCII对应的数字为：L = 76，O = 79，V = 86，E = 69
      2. L的密文 76^3 ≡ c (mod 33),438976 ≡ c (mod 33),
   8. 解密：c^d ≡ m (mod n)
      1.

** 算法实现（C语言）

*** 取素数p和q的值
    - C语言中超大数值的存储及运算
    - 素性测试

*** 计算欧拉函数值

*** 计算模反元素值
